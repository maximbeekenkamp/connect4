open! CS17SetupGame;
open Game; 

module AIPlayer = (MyGame: Game) => {
  module PlayerGame = MyGame

    /*
    Input: 
      lst, a non empty list of moves (these will be generated by the legalMoves() proc earlier)
      f, a procedure that consumes a move and outputs a float

    Output:
      a tuple containing
        the move that results in the maximum value when the move is put through procedure f
        the value of putting the move through procedure f

    let's say we have a function called f that is (move) => switch(move){ | Move(x) => float_of_int(x)})
    it creates a float based on the integer of the move

    OI: [Move(0), Move(1000)], f
    RI: [Move(1000)], f
    RO: (Move(1000), 1000.)
    OO: (Move(1000), 1000.)
    
    OI: [Move(1000)]
    RI: N/A
    RO: N/A
    OO: (Move(1000), 1000.)
    */  
    
  let rec argMax: (list(PlayerGame.move), PlayerGame.move => float) => (PlayerGame.move, float) =
    (lst, f) =>
      switch (lst) {
      | [] => failwith("Domain error")
      | [a] => (a, f(a))
      | [hd, ...tl] =>
        let (rn, rf) = argMax(tl, f);
        let hdf = f(hd);
        if (rf > hdf) {
          (rn, rf);
        } else {
          (hd, hdf);
        };
      };

  /*
  Input: 
      lst, a list of moves (these will be generated by the legalMoves() proc earlier)
      f, a procedure that consumes a move and outputs a float
  Output:
      a tuple containing
        the move that results in the minimum value when the move is put through procedure f
        the value of putting the move through procedure f
  */
  let argMin: (list(PlayerGame.move), PlayerGame.move => float) => (PlayerGame.move, float) =
    (lst, f) => {
      let fneg = x => (-1.) *. f(x);
      let (move, float) = argMax(lst, fneg);
      (move, float *. -1.)
    };

  /*
  Input: 
    s, a state
    d, an integer that represents the current depth of the minimax procedure
  Output:
    a tuple consisting of a Some(move) and a value
    this move will be the best move for the current player to make

  Note: Chance asked on edStem and we received permission to write the Recursion Diagram like this

  OI: initial state, 3 
  RI: all the states resulting from calling nextBoard on each of the possible legal moves with our initial state, depth of 3-1 = 2
      this continues until either we hit a terminal state OR our depth becomes 0
  RO: an option resulting from running argMax on all of the potential moves and their estimatedValues. 
      This leads to us making the move that leads to the board with the highest value from static evaluation.
  OO: Let's say that we are in a board where making Move(0) results in a win at the first level of depth (i.e. 
      in the next turn), but there are no other potential victories within a depth of three. In that case, 
      minimax will evaluate values of terminal states and also states down to depth 3, and it will recur all the way back 
      to the top, telling us that making Move(1) has such and such value based on a depth of 3, move(2) etc. etc.
      At this final level, calling argMax results in us seeing the victory value of 2000 from Move(0) and as such that move
      and it's value is output.

  This part below was what I originally wrote, but you can ignore it for the one above, 
  which was amended based on Stephen's suggestions.
  
  Let's say we have a state called state.

  OI: state, 3
  RI: this will be called for every potential legal move.
      each legal move will result in a recursive input of the state that 
      occurs when you apply that legal move to our original state. the depth is now 2.
  RO: an option of the best possible move to make to maximize estimate value 
      AND the float that is the value
  OO: an option of the best possible move to make to maximize estimate value
      AND the float that is the value

  */  

  let rec minimax: (PlayerGame.state, int) => (option(PlayerGame.move), float) =
    (s, depth) =>
      switch (depth) {
      | 0 => (None, PlayerGame.estimateValue(s))
      | _ =>
        switch (PlayerGame.gameStatus(s)) {
        | Ongoing(P1) => {
          let (move, value) = argMax(PlayerGame.legalMoves(s), (move) => {let (move, value) = minimax(PlayerGame.nextState(s, move), depth - 1); value});
          (Some(move), value)}
        | Ongoing(P2) => {
          let (move, value) = argMin(PlayerGame.legalMoves(s), (move) => {let (move, value) = minimax(PlayerGame.nextState(s, move), depth - 1); value});
          (Some(move), value)} 
        | Draw => (None, PlayerGame.estimateValue(s))
        | Win(_) => (None, PlayerGame.estimateValue(s))
        }
      };
  
  /*
  Input: 
    s, a state
  Output:
    a move that is the best move for the current player to make based on the minimax procedure
  */
  let nextMove: PlayerGame.state => PlayerGame.move = inState => {
    let (move, _) = minimax(inState, 5);
    switch(move) {
      | None => failwith("nextMove: minimax did not generate any moves.")
      | Some(x) => x
    }
  };

  /* put your team name here! */
  let playerName = "RobotBoy";
  
};

module TestGame = Connect4.Connect4;
open Player;

module TestAIPlayer = AIPlayer(TestGame); 
module MyAIPlayer:Player = TestAIPlayer;
open TestAIPlayer; 

/* insert test cases for any procedures that don't take in 
 * or return a state here */

checkExpect(argMax([Move(1)], (move) => switch(move){ | Move(x) => float_of_int(x)}), (Move(1), 1.), "argMax: testing 1");
checkExpect(argMax([Move(1), Move(1000)], (move) => switch(move){ | Move(x) => float_of_int(x)}), (Move(1000), 1000.), "argMax: testing on list of 2");
checkExpect(argMin([Move(1)], (move) => switch(move){ | Move(x) => float_of_int(x)}), (Move(1), 1.), "argMin: testing 1");
checkExpect(argMin([Move(1), Move(1000)], (move) => switch(move){ | Move(x) => float_of_int(x)}), (Move(1), 1.), "argMin: testing on list of 2");